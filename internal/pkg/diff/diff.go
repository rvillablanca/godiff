package diff

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/pkg/errors"
	"github.com/rvillablanca/godiff/internal/pkg/utils"
)

func Patch(oldDir, newDir, destDir string) error {
	err := utils.ValidateDirectories(oldDir, newDir, destDir)
	if err != nil {
		return err
	}

	fmt.Println("looking for files...")
	var oldFiles = FindFilesFiltering(oldDir, SkipKnownFolders)
	var newFiles = FindFilesFiltering(newDir, SkipKnownFolders)

	toAdd := make([]string, 0)
	toRemove := make([]string, 0)
	toReplace := make([]string, 0)

	//Archivos a eliminar
oldIteration:
	for _, oldFile := range oldFiles {
		for _, newFile := range newFiles {
			if newFile == oldFile {
				continue oldIteration
			}
		}
		toRemove = append(toRemove, oldFile)
	}

	//Archivos que hay que agregar
newIteration:
	for _, newFile := range newFiles {
		for _, oldFile := range oldFiles {
			if newFile == oldFile {
				continue newIteration
			}
		}

		if ShouldSkip(newFile, SkipKnownFolders) {
			continue newIteration
		}

		toAdd = append(toAdd, newFile)
	}

	//Se quitan los archivos a eliminar de la lista de archivos a comparar.
loop:
	for i := 0; i < len(oldFiles); i++ {
		old := oldFiles[i]
		for _, rem := range toRemove {
			if old == rem {
				oldFiles = append(oldFiles[:i], oldFiles[i+1:]...)
				i--
				continue loop
			}
		}
	}

	fmt.Println("comparing files...")
	for _, v := range oldFiles {
		v1 := filepath.Join(oldDir, v)
		v2 := filepath.Join(newDir, v)
		equal, err := CompareFiles(v1, v2)
		if err != nil {
			return errors.Wrap(err, "error while comparing old and new files")
		}
		if !equal {
			toReplace = append(toReplace, v)
		}
	}

	for _, file := range toAdd {
		srcf := filepath.Join(newDir, file)
		dstf := filepath.Join(destDir, file)
		dstdirs := filepath.Dir(dstf)
		err = os.MkdirAll(dstdirs, os.ModePerm)
		if err != nil {
			return errors.Wrap(err, "error when creating directory to copy new files")
		}
		err = utils.Copy(srcf, dstf)
		if err != nil {
			return errors.Wrapf(err, "error while creating file %v", srcf)
		}
	}

	for _, file := range toReplace {
		srcf := filepath.Join(newDir, file)
		dstf := filepath.Join(destDir, file)
		dstdirs := filepath.Dir(dstf)
		err = os.MkdirAll(dstdirs, os.ModePerm)
		if err != nil {
			return errors.Wrap(err, "error while creating directories to copy files to replace")
		}
		err = utils.Copy(srcf, dstf)
		if err != nil {
			return errors.Wrapf(err, "error while copying file %v", srcf)
		}
	}

	//Se crea archivo con lista de archivos a eliminar sÃ³lo si aplica
	if len(toRemove) > 0 {
		fileName := filepath.Join(destDir, "to_delete.sh")
		f, err := os.Create(fileName)
		if err != nil {
			return errors.Wrap(err, "error when creating list of files to delete")
		}
		defer utils.CloseQuietly(f)
		_, _ = f.WriteString("#!/usr/bin/env sh\n")
		_, _ = f.WriteString("# THIS FILE WAS GENERATED BY godiff\n")

		for _, file := range toRemove {
			_, _ = f.WriteString("rm " + file + "\n")
		}
		fmt.Println("files to be removed have been listed in to_delete.sh")
	}

	fmt.Println("path created")
	return nil
}
